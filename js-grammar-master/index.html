<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>자바스크립트 기초 문법</title>
  </head>

  <body>
    <script>
//문자열, 숫자 다룰때 주의점
const text = '2';
const num = 2;
const result = text + num ; //문자와 숫자는 산술적으로 연산할 수 없으니 num의 숫자값을 강제로 문자형 변환 처리
console.log(result); //2로 변환된 두 개의 문자값을 이어붙여서 문자 '2 2'

//숫자가 문자로 형변환 되는 경우
//대입 연산자 기준으로는 오른쪽 식이 먼저 연산된 뒤, 결과값이 왼쪽에 대입
// 표현식 안쪽에서 왼쪽에서 오른쪽으로 연산 처리됨
const num1 = 1;
const num2 = 2;
const num3 = "3";   //문자 3
console.log(num1 + num2 + num3); //'33' 숫자3이랑 문자3
console.log(num3 + num2 + num1); // '321' 문자3 표현식 안쪽에서 왼쪽에서 오른쪽으로 연산처리됨. 문자3 + 2 + 1 
// 문자로 321로 바뀌는 이유: "3" + 2는 **"32"**라는 문자열이 됩니다. 문자열이 된 이후에 1이 더해짐.

//연산자 : 특성 값을 나타내기 위한 연산처리 구문, 종류:산술-,비교-,대입-

//산술연산자: 수식에 대한 연산자
  console.log(2+3);
  console.log(2-3);
  console.log(2*3);
  console.log(4/2); //나눈값의 몫을 출력
  console.log(5%2); //나눈값의 나머지 입력
  //  % 나머지연산자가 주로 쓰이는 경우: 전체 게시글 대비 페이지 갯수 계산할 때 처리
  // 전체 게시글 42개, 한 페이지당 10개씩 게시글 보이게 출력.
  //console.log(42%10); 
  console.log(2 ** 3); // 2의 3제곱, 결과는 8   2*2*2 제곱승 처리하는 연산자

//비교연산자: true,fals같은 boolean을 나타내는 비교하기 위한 연산
  console.log(2 == "2");  //=2개 == True가 반환됨. 자료형은 무시하고 값만 비교
  console.log(2 === "2");  //=3ro === False가 반환됨. 자료형과 값을 모두 비교
  console.log(2 != "2"); //False. 앞에 !를 붙이면 값이 같이 않을 때 참(True) -자료형 무시하고 값만 비교   
  console.log(2 !== "2"); //True. 위와 같은 로직이지만 값과 자료형 같이 비교
  console.log(2<3); 
  console.log(2<=3);

  // &&연산자
  console.log(true && true); //두개다 참이어야 참으로 표현됨.
  console.log(true || false);  // //복수개의 조건 중 하나만 참이어도 참으로 인식   결과: true
  console.log(false || false); // 결과: false
  console.log(false || true);  // 결과: true
  console.log(true || true);  // true를 출력



//대입연산자: 우항을 먼저 연산해서 좌항에 대입해주는 대입연산자
//복합대입연산자
let num4 = 3;
num4 += 2;  // num = num + 2 와 동일
console.log(num4);  // 출력: 5   자기 자신에 추가연산된 결과값으로 덮어쓰기

let num5 = 0;
//num5 ++= 1;  // 잘못된 구문
num5++;  // 후위 증감 연산자: 초기값을 먼저 활용한 후 뒤에 값 증가
          //현재 값을 사용한 후 값이 1 증가
console.log(num5++);  // 출력: 1

let num6 = 0; 
++num6;  // 전위 증감 연산자: 초기값을 먼저 1 증가시킨 후 사용
console.log(++num6);  // 출력: 2

//const : 재할당이 불가능한 변수
// let : 재할당 가능(기존 메모리에 할당된 값 변경 가능)

const DB = "엄청 중요한 DB 문자정보"; //원시형 자료
//DB = '쓸데없는정보';
//console.log(DB);

const student1 = { 
 name: 'Emily',   //property (key:value)
 age : 30,
 isFemal: true,
};
student1.name="Emma";  //const로 
console.log(student1);

//참조형 자료는 값 자체가 callstack에 있는 메모리 공간에 값이 할당되어 있는 것이 아닌 메모리힙에 저장되어 있는 위치참조값이 할당됨.
//결과적으로 const방식으로 참조형 데이터를 할당했더라도 값을 변경하면 callstack에 할당되어 있는 참조값을 변경하는 것이 아닌
//참조값이 가리키고 있는 메모리 힙상의 값을 변경함
//변수값이 할당되어 있는 callstack입장에서는 값 변경을 인지하지 않아서 const방식이라고 하더라도 값 변경이 일어남

const colors = ["red", "green", "blue"];
colors[0] = "hotpink";  // 첫 번째 요소를 "hotpink"로 변경
console.log(colors);    // 출력: ["hotpink", "green", "blue"]
// 아래와 같이 colors에 등록되어 있는 참조형 자료의 값을 변경하는 것이 아닌
//아예 새로운 값을 대입하려고 하면 에러 발생
//메모리힙에 새로운 배열데이터가 저장되면서 새로운 위치값은 새로운 참조값이 생김
//callstack상에 대입된 참조값 자체가 물리적으로 변경되므로 재할당 불가하다는 에러구문이 뜸.

colors = [1,2,3]



//이 배열 자체는 재할당할 수 없지만, 배열의 요소는 변경 가능합니다. 즉, 배열의 참조는 고정되지만 배열 내부의 값을 수정할 수 있습니다.
 
//cosnt로 선언한 원시형 자료 대입시 값 변경이 불가한데,
//참조형 자료는 왜 값 변경이 가능한 지 고민
//자바스크립트 엔진의 구조와 참조형 자료와 원시형 자료의 특성을 고려해서 유추해보세요.
//힌트: 재할당의 개념: 기존 변수에 할당된 값이 변경되는 경우




/* 재할당과 메모리 구조
원시형 자료는 재할당이 일어날 때 기존의 메모리 공간을 완전히 덮어씌우는 방식으로 값이 바뀌게 됩니다. 하지만 const는 이를 허용하지 않으므로 오류가 발생합니다.
참조형 자료는 재할당이 아닌 메모리 주소가 가리키는 값 자체를 수정하는 것이기 때문에 const로 선언해도 값의 변경이 가능합니다. 참조형 자료의 메모리 주소 자체가 변경되지 않으면, 그 내부의 데이터는 수정이 가능하기 때문입니다.
5. 결론
원시형 자료는 메모리에 값 자체가 저장되므로 const로 선언 시 값 자체를 변경할 수 없습니다.

참조형 자료는 메모리에 값의 주소를 저장하므로 const로 선언 시에도 주소는 고정되지만, 주소가 가리키는 데이터는 수정할 수 있습니다.

참조형 자료의 값이 변경 가능한 이유는 재할당이 아닌 값의 수정이기 때문입니다.
*/

</script>
  </body>
</html>
